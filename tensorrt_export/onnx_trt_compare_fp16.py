#!/usr/bin/env python3
# Template auto-generated by polygraphy [v0.47.1] on 06/05/23 at 12:36:31
# code gen with onnx_trt_compare.sh
# but i edit the code to make it more readable
import tensorrt as trt
import os
import shutil
import numpy as np
from polygraphy.logger import G_LOGGER
G_LOGGER.module_severity = {'': G_LOGGER.VERBOSE}
from colored import stylize, fg
from polygraphy import constants
import onnx
from polygraphy.backend.common import SaveBytes
from polygraphy.backend.onnx import modify_outputs, onnx_from_path, ModifyOutputs
from polygraphy.backend.onnxrt import OnnxrtRunner, SessionFromOnnx
from polygraphy.backend.trt import CreateConfig as CreateTrtConfig, EngineBytesFromNetwork, EngineFromBytes, ModifyNetworkOutputs, NetworkFromOnnxPath, Profile, TrtRunner
from polygraphy.common import TensorMetadata
from polygraphy.comparator import Comparator, CompareFunc, DataLoader
from polygraphy.exception import PolygraphyException
from polygraphy.backend.trt import network_from_onnx_path



# --dir info--
now_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(now_dir)
import sys
sys.path.append(project_dir)
from tensorrt_export.onnx2trt_no_cache import (
    get_network_profiles,
    MyLogger,
)


output_dir = os.path.join(project_dir, "output")
new_onnx_dir = os.path.join(output_dir, "onnx_output_no_cache_new")
if not os.path.exists(new_onnx_dir):
    os.mkdir(new_onnx_dir)
else:
    for file in os.listdir(new_onnx_dir):
        os.remove(os.path.join(new_onnx_dir, file))
new_onnx_dir2 = os.path.join(output_dir, "onnx_output_no_cache_new2")
if not os.path.exists(new_onnx_dir2):
    os.mkdir(new_onnx_dir2)
else:
    for file in os.listdir(new_onnx_dir2):
        os.remove(os.path.join(new_onnx_dir2, file))

onnx_path = os.path.join(output_dir, "onnx_output", "chatglm2_6b.onnx")
new_onnx_path = os.path.join(new_onnx_dir, "chatglm2_6b.onnx")
new_onnx_path2 = os.path.join(new_onnx_dir2, "chatglm2_6b.onnx")
model_dir = os.path.join(project_dir, "models")
trt_model_path = os.path.join(model_dir, "chatglm6b2-bs1_with_cache.plan")
time_cache_path = os.path.join(output_dir, "fp16_markAll_no_cache.cache")
use_time_cache = False
num_layers = 1


# Data Loader
dtype = np.dtype(np.int32)
data_loader = DataLoader(
    input_metadata=TensorMetadata()
    .add('input_ids', dtype=dtype, shape=(1, 512))
    .add('position_ids', dtype=np.int32, shape=(1, 512))
)
# load onnx

print("loading onnx model from", onnx_path)
onnx_model = onnx_from_path(onnx_path)
# this layer will output None in onnxrt
bool_tensor_list = ["/transformer/encoder/layers.0/mlp/Sigmoid_output_0"]
for node in onnx_model.graph.node:
    # print(node.name, node.op_type)
    # this layer is a bool tensor, it will cause error when run TensorRT engine
    if node.op_type == "Equal":
        print("find bool", node.name)
        bool_tensor_list.extend(node.output)
input_list = onnx_model.graph.input
input_names = [i.name for i in input_list]
output_list = onnx_model.graph.output
output_names = [o.name for o in output_list]
exclude_outputs = input_names + bool_tensor_list
# mark all layers as output for onnx model
# warning this will make the onnx model output all layers with no type and no shape
new_onnx_model = modify_outputs(
    model=onnx_model,
    outputs=constants.MARK_ALL,
    exclude_outputs=exclude_outputs,
)
new_output_list = new_onnx_model.graph.output
new_output_names = [o.name for o in new_output_list]
onnx_input_num = len(new_onnx_model.graph.input)
onnx_output_num = len(new_onnx_model.graph.output)
print("onnx input num:", onnx_input_num, "onnx output num:", onnx_output_num)
onnx.save_model(
    new_onnx_model,
    new_onnx_path,
    save_as_external_data=True,
    all_tensors_to_one_file=False
)
# load onnx_runtime
build_onnx_rt_session = SessionFromOnnx(new_onnx_path)
# get onnx runtime output tensor info(name, type, shape)
sess = build_onnx_rt_session()
bool_tensor_list = []
sess_output = sess.get_outputs()
for node in sess_output:
    if node.type == "tensor(float)":
        dtype = onnx.TensorProto.FLOAT
    elif node.type == "tensor(bool)":
        print("find bool", node.name)
        bool_tensor_list.append(node.name)
        dtype = onnx.TensorProto.BOOL
    elif node.type == "tensor(int64)":
        dtype = onnx.TensorProto.INT64
    else:
        print("unknown dtype:", node.type)
        raise ValueError
    output_tensor = onnx.helper.make_tensor_value_info(
        node.name, dtype, None
    )
    # replace the output tensor
    for i, vi in enumerate(new_onnx_model.graph.output):
        if vi.name == node.name:
            new_onnx_model.graph.output[i].CopyFrom(output_tensor)
# save again
for file in os.listdir(new_onnx_dir):
    shutil.copy(os.path.join(new_onnx_dir, file), new_onnx_dir2)
onnx.save_model(
    new_onnx_model,
    new_onnx_path2,
    save_as_external_data=True,
    all_tensors_to_one_file=False
)
print("===========onnx model loaded=========================")
# build trt engine
print("===========building trt engine=========================")
# prepare trt builder
builder = trt.Builder(MyLogger())
builder.max_threads = os.cpu_count() // 2
config = builder.create_builder_config()
# use fp16
config.flags = 1 << int(trt.BuilderFlag.FP16)
# disable TF32
config.flags = config.flags & ~(1 << int(trt.BuilderFlag.TF32))
print("use fp16? ", config.get_flag(trt.BuilderFlag.FP16))
# read time cache
if use_time_cache:
    if os.path.exists(time_cache_path):
        time_cache = open(time_cache_path, "rb").read()
        if time_cache is None:
            time_cache = b""
            print(stylize("read time cache failed", fg("red")))
        else:
            print(stylize(f"read time cache from {time_cache_path}", fg("green")))
    else:
        time_cache = b""
        print(stylize("time cache will init with empty.", fg("green")))

    # set time cache
    cache = config.create_timing_cache(time_cache)
    config.set_timing_cache(cache, False)
profile_list = get_network_profiles(builder, num_layers=num_layers)
for profile in profile_list:
    config.add_optimization_profile(profile)

_b, network, _p = NetworkFromOnnxPath(new_onnx_path2)()

# network = network_from_onnx_path(onnx_path)
# set_network_outputs = ModifyNetworkOutputs(
#     network=network,
#     outputs=constants.MARK_ALL,
#     exclude_outputs=bool_tensor_list
# )
# wo_b, network, _p = set_network_outputs()
network_input_number = network.num_inputs
network_output_number = network.num_outputs
print("TensorRT input num:", network_input_number, "TensorRT output num:", network_output_number)
serialized_engine = builder.build_serialized_network(network, config)
if serialized_engine is not None:
    with open(trt_model_path, "wb") as f:
        f.write(serialized_engine)
    # save_engine(trt_engine, tensorrt_engine_path)
    print("==tensorRT engine compile done==")

# save time cache
if use_time_cache and not os.path.exists(time_cache_path):
    time_cache = config.get_timing_cache()
    if time_cache is not None:
        time_cache_data = time_cache.serialize()
        open(time_cache_path, "wb").write(time_cache_data)
        print(
            stylize(
                "save time cache to {}".format(time_cache_path),
                fg("green")
            )
        )

# profiles = [
#     Profile().add('input_ids:[1,512] position_ids:[1,2,512] attention_mask:[1,1,512,512] past_key_values.0.decorder.key:[0,1,32,128] past_key_values.0.decorder.value', min=[0, 1, 32, 128], opt=[0, 1, 32, 128], max=[0, 1, 32, 128])
# ]
# create_trt_config = CreateTrtConfig(memory_pool_limits=2 * (1024 ** 3), profiles=profile_list)
# build_engine = EngineBytesFromNetwork(set_network_outputs, config=create_trt_config)
# save_engine_bytes = SaveBytes(build_engine, path=trt_model_path)
save_engine_bytes = SaveBytes(serialized_engine, path=trt_model_path)
deserialize_engine = EngineFromBytes(save_engine_bytes)
print("===========trt engine build OK=========================")

# Runners
runners = [
    OnnxrtRunner(build_onnx_rt_session),
    TrtRunner(deserialize_engine),
]

# Runner Execution
results = Comparator.run(runners, data_loader=data_loader)

success = True
# Accuracy Comparison
compare_func = CompareFunc.simple(rtol={'': 1e-4}, atol={'': 1e-4})
success &= bool(Comparator.compare_accuracy(results, compare_func=compare_func))

# Report Results
if not success:
    raise PolygraphyException('FAILED')
